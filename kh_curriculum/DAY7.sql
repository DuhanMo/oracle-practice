-- DAY7 수업내용
-- INSERT, UPDATE, DELETE, SELECT
-- DML(Data Manipulation Language)
-- 데이터 조작언어 : 테이블에 값을 삽입하거나, 수정하거나, 삭제하거나,조회하는 언언
-- INSERT : 새로운 행을 추구하는 구문, 테이블의 행 갯수가 증가한다.
-- [표현식]
-- INSERT INTO 테이블명 VALUES(데이터,데이터...) : 테이블에 모든 컬럼에 대해 값을 INSERT할때 사용
-- INSERT INTO 테이블명(컬럼명,컬럼명,...) VALUES(데이터,데이터...) : 테이블의 일부컬럼에 대해서 값을 INSERT할때 사용
INSERT INTO EMPLOYEE(EMP_ID,EMP_NAME,EMP_NO,EMAIL,PHONE,DEPT_CODE,JOB_CODE,SAL_LEVEL,SALARY,BONUS,
                     MANAGER_ID,HIRE_DATE,ENT_DATE,ENT_YN)
VALUES(900,'장채현','901122-1080503','jang_ch@kh.or.kr','01051512345','D1','J7','S3',4300000,0.2,'200',SYSDATE,NULL,DEFAULT);

SELECT * FROM EMPLOYEE;

-- INSERT시에 VALUES 대신 서브쿼리를 이용할 수 있다.
CREATE TABLE EMP_01(
   EMP_ID      NUMBER
 , EMP_NAME    VARCHAR2(30)
 , DEPT_TITLE  VARCHAR2(20)
);

INSERT INTO EMP_01(
   SELECT EMP_ID,EMP_NAME,DEPT_TITLE
   FROM EMPLOYEE
   LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
);

SELECT * FROM EMP_01;
DROP TABLE EMP_DEPT_D1;
CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID,EMP_NAME,DEPT_CODE,HIRE_DATE
   FROM EMPLOYEE
   WHERE 1=1; -- 참을 의미하며 WHERE 1=1로 하면 구조와 내용 전부를 복사

SELECT * FROM EMP_DEPT_D1;

CREATE TABLE EMP_MANAGER
AS SELECT EMP_ID,EMP_NAME,MANAGER_ID
   FROM EMPLOYEE
   WHERE 1=0; --테이블의 구조만 복사할 때 1=0(거짓)을 부여

SELECT * FROM EMP_MANAGER;

-- INSERT ALL : INSERT시에 사용하는 서브쿼리가 같은 경우
--              두 개 이상의 테이블에 INSERT ALL을 이용하여
--              한번에 데이터를 삽입할 수 있다.
--              단, 각 서브쿼리의 조건절이 같아야한다.

-- EMP_DEPT_D1테이블에 EMPLOYEE테이블에 있는 부서코드가 D1인 직원을 조회해서
-- 사번,이름, 소속부서,입사일을 삽입하고,
-- EMP_MANAGER테이블에 EMPLOYEE테이블에 있는 부서코드가 D1인 직원을 조회해서
-- 사번, 이름,관리자 사번을 삽입하세요.
INSERT INTO EMP_DEPT_D1(
   SELECT EMP_ID,EMP_NAME,DEPT_CODE,HIRE_DATE
   FROM EMPLOYEE
   WHERE DEPT_CODE = 'D1'
);

INSERT INTO EMP_MANAGER(
   SELECT EMP_ID,EMP_NAME,MANAGER_ID
   FROM EMPLOYEE
   WHERE DEPT_CODE='D1'
);

SELECT * FROM EMP_DEPT_D1;
SELECT * FROM EMP_MANAGER;

DELETE FROM EMP_DEPT_D1;
DELETE FROM EMP_MANAGER;

INSERT ALL
INTO EMP_DEPT_D1 VALUES(EMP_ID,EMP_NAME,DEPT_CODE,HIRE_DATE)
INTO EMP_MANAGER VALUES(EMP_ID,EMP_NAME,MANAGER_ID)
SELECT EMP_ID,EMP_NAME,DEPT_CODE,HIRE_DATE,MANAGER_ID
   FROM EMPLOYEE
   WHERE DEPT_CODE = 'D1';

-- EMPLOYEE테이블에서 입사일 기준으로 2000년 1월 1일 이전에 입사한
-- 사원의 사번, 이름, 입사일, 급여를 조회하여
-- EMP_OLD 테이블에 삽입하고
-- 그 이후에 입사한 사원은 EMP_NEW 테이블에 삽입하세요.
CREATE TABLE EMP_OLD
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
   FROM EMPLOYEE
   WHERE 1 = 0;

CREATE TABLE EMP_NEW
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
   FROM EMPLOYEE
   WHERE 1 = 0;



INSERT ALL
WHEN HIRE_DATE < '2000/01/01'
THEN INTO EMP_OLD VALUES(EMP_ID,EMP_NAME,HIRE_DATE,SALARY)
WHEN HIRE_DATE >= '2000/01/01'
THEN INTO EMP_NEW VALUES(EMP_ID,EMP_NAME,HIRE_DATE,SALARY)
SELECT EMP_ID,EMP_NAME,HIRE_DATE,SALARY
FROM EMPLOYEE;

-- UPDATE : 테이블에 기록된 컬럼의 값을 수정하는 구문
--          테이블의 전체 행 갯수는 변화가 없다.
--  [표현식]
-- UPDATE 테이블명 SET 컬럼명=바꿀값, 컬럼명=바꿀값.....
-- [WHERE 컬럼명 비교연산자 비교값];

CREATE TABLE DEPT_COPY1
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY1;

UPDATE DEPT_COPY1
SET DEPT_TITLE='전략기획팀'
WHERE DEPT_ID = 'D9';

DROP TABLE DEPT_COPY1;

-- UPDATE 시에도 서브쿼리르 이용할 수 있다.
-- UPDATE 테이블명
-- SET 컬럼명 = (서브쿼리)
CREATE TABLE EMP_SALARY
AS SELECT EMP_ID,EMP_NAME,DEPT_CODE,SALARY,BONUS
   FROM EMPLOYEE;

SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN ('유재식','방명수');

-- 평상시 유재식 사원을 부러워하던 방명수 사원의
-- 급여와 보너스율을 유재식 사원과 동일하게 변경해 주기로 했다.
-- 이를 반영하는 UPDATE문을 작성해보세요.
UPDATE EMP_SALARY
SET SALARY = (SELECT
                  SALARY
               FROM
                   EMPLOYEE
               WHERE EMP_NAME='유재식')
    , BONUS = (SELECT
                  BONUS
               FROM
                   EMPLOYEE
               WHERE EMP_NAME='유재식')
WHERE EMP_NAME = '방명수';

-- 다중행 다중열 서브쿼리를 이용한 UPDATE문
-- 방명수 사원의 급여 인상 소식을 전해들은 다른 사원들이
-- 단체로 파업을 진행했다.
-- 노옹철,전형돈,정중하,하동운 사원의 급여와 보너스를
-- 유재식 사원의 급여와 보너스와 같게 변경하는 UPDATE문 작성
UPDATE EMP_SALARY
SET (SALARY,BONUS) = (SELECT SALARY,BONUS
                      FROM EMPLOYEE
                      WHERE EMP_NAME='유재식')
WHERE EMP_NAME IN('노옹철','전형돈','정중하','하동운');

SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN ('유재식','방명수','노옹철','전형돈','정중하','하동운');

-- UPDATE시 변경할 값은 해당 컬럼에 대한 제약조건에 위배되지 않아야한다.
UPDATE EMPLOYEE
SET DEPT_CODE='65'  --> FOREIGN KEY 제약조건 위배
WHERE DEPT_CODE='D6';

UPDATE EMPLOYEE
SET EMP_NAME = NULL --> NOT NULL 제약조건 위배
WHERE EMP_ID =200;

ROLLBACK;

-- DELETE : 테이블의 행을 삭제하는 구문이다.
--          테이블의 행의 갯수가 줄어든다.
-- [표현식]
--  DELETE FROM 테이블명 WHERE 조건설정
--  만약 WHERE 조건을 설정하지 않으면 모든 행이 다 삭제된다.
COMMIT;

DELETE FROM EMPLOYEE;
SELECT * FROM EMPLOYEE;

ROLLBACK;

DELETE FROM EMPLOYEE
WHERE EMP_NAME = '장채현';

ROLLBACK;

-- FOREIGN KEY제약조건이 설정되어있는 경우
-- 참조되고 있는 값에 대해서는 삭제할 수 없다.
DELETE FROM DEPARTMENT
WHERE DEPT_ID='D1';

-- FOREING KEY 제약조건이 설정되어 있어도
-- 참조되고 있지 않는 값에 대해서는 삭제 가능
DELETE FROM DEPARTMENT
WHERE DEPT_ID='D3';

ROLLBACK;

-- SYS_C007118
-- 삭제 시 FOREIGN KEY 제약조건으로 컬럼 삭제가 불가능한 경우
-- 제약조건을 비활성화 할 수 있다.
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='EMPLOYEE';

ALTER TABLE EMPLOYEE
DISABLE CONSTRAINT SYS_C007118 CASCADE;


DELETE FROM DEPARTMENT
WHERE DEPT_ID='D1';

SELECT * FROM DEPARTMENT;
SELECT * FROM EMPLOYEE;

ROLLBACK;

INSERT INTO DEPARTMENT VALUES('D1','인사관리부','L1');

-- 비활성화된 제약조건을 다시 활성화
ALTER TABLE EMPLOYEE
ENABLE CONSTRAINT SYS_C007118;

-- TRUNCATE : 테이블의 전체 행을 삭제할 시 사용한다.
--            DELETE 보다 수행 속도가 더 빠르다.
--            ROLLBACK을 통해 복구할 수 없다.

SELECT * FROM EMP_SALARY;
COMMIT;

DELETE FROM EMP_SALARY;
SELECT * FROM EMP_SALARY;


ROLLBACK;

TRUNCATE TABLE EMP_SALARY;
ROLLBACK;
SELECT * FROM EMP_SALARY;

-- TCL(Transaction Controll Language)
-- 트랜젝션 제어 언어
-- COMMIT과 ROLLBACK이 있다.
SELECT * FROM EMPLOYEE;
-- 트랜젝션이란?
-- 한꺼번에 수행되어야 할 최소의 작업단위를 말한다.
-- 하나의 트랜젝션으로 이루어진 작업은 반드시 한꺼번에 완료(COMMIT)
-- 되어야 하며, 그렇지 않은 경우에는 한번에 취소(ROLLBACK)되어야 한다.
-- 둘 이상의 트렌젝션이 서로의 작업에 영향을 주지 않는다.

-- COMMIT : 트렌젝션 작업이 정상 완료되면 변경 내용을 영구히 저장
-- ROLLBACK: 트랜젝션 작업을 취소하고, 최근 COMMIT한 시점으로 이동
-- SAVEPOINT 세이브포인트명 : 현재 트랜잭션 작업 시점에 이름을 정해준다.
--                            하나의 트랜잭션 안에 구역을 나눔
-- ROLLBACK TO 세이브포인트명 : 트랜젝션 작업을 취소하고
--                              SAVEPOINT 시점으로 이동

CREATE TABLE USER_TBL(
   USERNO      NUMBER UNIQUE
 , ID          VARCHAR2(20) PRIMARY KEY
 , PASSWORD    CHAR(20) NOT NULL
);

SELECT * FROM USER_TBL;

INSERT INTO USER_TBL VALUES(1,'test1','pass1');
INSERT INTO USER_TBL VALUES(2,'test2','pass2');
INSERT INTO USER_TBL VALUES(3,'test3','pass3');
COMMIT;
ROLLBACK;
INSERT INTO USER_TBL VALUES(4,'test4','pass4');
SAVEPOINT SP1;
INSERT INTO USER_TBL VALUES(5,'test5','pass5');

ROLLBACK TO SP1;

ROLLBACK;

-- DDL
-- ALTER : 객체를 수정하는 구문
-- 테이블 객체 수정 : ALTER TABLE 테이블명 수정할내용;
-- 컬럼 추가/삭제/변경,  제약조건 추가/삭제/변경
-- 테이블명 변경, 제약조건 이름 변경

-- 컬럼 추가
SELECT * FROM DEPT_COPY;

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

ALTER TABLE DEPT_COPY
ADD (LNAME VARCHAR2(20));

-- 컬럼 삭제
ALTER TABLE DEPT_COPY
DROP COLUMN LNAME;

-- 컬럼 생성 시 DEFAULT값 지정
ALTER TABLE DEPT_COPY
ADD (CNAME VARCHAR2(20) DEFAULT '한국');

-- 컬럼에 제약조건 추가
CREATE TABLE DEPT_COPY2
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY2;

ALTER TABLE DEPT_COPY2
ADD CONSTRAINT PK_DEPT_ID2 PRIMARY KEY(DEPT_ID);
ALTER TABLE DEPT_COPY2
ADD CONSTRAINT UN_DEPT_TITLE2 UNIQUE(DEPT_TITLE);
ALTER TABLE DEPT_COPY2
MODIFY LOCATION_ID CONSTRAINT NN_LID NOT NULL;
DESC DEPT_COPY2;

-- 컬럼 자료형 수정
ALTER TABLE DEPT_COPY2
MODIFY DEPT_ID CHAR(3)
MODIFY DEPT_TITLE VARCHAR2(30)
MODIFY LOCATION_ID VARCHAR2(2);

DESC DEPT_COPY2;

-- 컬럼의 크기를 줄이는 경우에는
-- 변경하려는 크기를 초과하는 값이 없을 때만 변경할 수 있다.
ALTER TABLE DEPT_COPY2
MODIFY DEPT_TITLE VARCHAR2(10);


SELECT LENGTHB(DEPT_TITLE) FROM DEPT_COPY2;

-- DEFAULT 값 변경
ALTER TABLE DEPT_COPY
MODIFY CNAME DEFAULT '아라';

SELECT * FROM DEPT_COPY;
DELETE FROM DEPT_COPY WHERE DEPT_ID='D0';
INSERT INTO DEPT_COPY VALUES('D0','아라생산부','L2',DEFAULT);

-- 컬럼 삭제 : DROP COLUMN 삭제할컬럼명 또는 DROP(삭제할컬럼명)
-- 데이터가 기록되어 있어도 삭제된다.
-- 삭제된 컬럼은 복구가 불가능
-- 테이블에는 최소 한개의 컬럼이 존재해야한다. --> 모든 컬럼 삭제 불가능
ALTER TABLE DEPT_COPY
DROP COLUMN DEPT_TITLE;

SELECT * FROM DEPT_COPY;

ALTER TABLE DEPT_COPY
DROP COLUMN CNAME;

ALTER TABLE DEPT_COPY
DROP COLUMN LOCATION_ID;

-- 지우려는 테이블에 최소 한개 이상의 컬럼이 남아있어야한다.
ALTER TABLE DEPT_COPY
DROP COLUMN DEPT_ID;

CREATE TABLE TB1(
   PK    NUMBER PRIMARY KEY
 , FK    NUMBER REFERENCES TB1
 , COL1  NUMBER
 , CHECK(PK > 0 AND COL1 >0)
);
-- 컬럼 삭제 시 참조하고 있는 컬럼이 있다면 삭제를 못한다.
ALTER TABLE TB1
DROP COLUMN PK;

-- 제약조건도 함께 삭제
ALTER TABLE TB1
DROP COLUMN PK CASCADE CONSTRAINT;

SELECT * FROM TB1;

SELECT * FROM DEPT_COPY2;

ALTER TABLE DEPT_COPY2
ADD (LNAME VARCHAR2(20));

ALTER TABLE DEPT_COPY2
DROP(LNAME);

ALTER TABLE DEPT_COPY2
DROP (LOCATION_ID,DEPT_TITLE);

ROLLBACK;

SELECT * FROM DEPT_COPY; -- ROLLBACK을 해도 복구가 안된다.

-- 제약조건 삭제
CREATE TABLE CONST_EMP1(
   ENAME       VARCHAR2(20)  NOT NULL
 , ENO         VARCHAR2(15)  NOT NULL
 , MARRIAGE    CHAR(1)    DEFAULT 'N'
 , EID         CHAR(3)
 , EMAIL       VARCHAR2(30)
 , JID         CHAR(2)
 , MID         CHAR(3)
 , DID         CHAR(2)
 -- 테이블 레벨로 제약조건 설정
 , CONSTRAINT CK_MARRIAGE CHECK(MARRIAGE IN ('Y','N'))
 , CONSTRAINT PK_EID PRIMARY KEY(EID)
 , CONSTRAINT UN_ENO UNIQUE(ENO)
 , CONSTRAINT UN_EMAIL UNIQUE(EMAIL)
 , CONSTRAINT FK_JID FOREIGN KEY(JID) REFERENCES JOB(JOB_CODE) ON DELETE SET NULL
 , CONSTRAINT FK_MID FOREIGN KEY(MID) REFERENCES CONST_EMP1 ON DELETE SET NULL
 , CONSTRAINT FK_DID FOREIGN KEY(DID) REFERENCES DEPARTMENT ON DELETE CASCADE
);

-- 제약조건 1개 삭제시
ALTER TABLE CONST_EMP1
DROP CONSTRAINT CK_MARRIAGE;

-- 제약조건 여러개 삭제시
ALTER TABLE CONST_EMP1
DROP CONSTRAINT FK_DID
DROP CONSTRAINT FK_JID
DROP CONSTRAINT FK_MID;
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT_COPY3';
-- NOT NULL 제약조건 삭제 시 MODIFY 사용
ALTER TABLE CONST_EMP1
MODIFY (ENAME NULL,ENO NULL);

-- 컬럼 이름 변경
CREATE TABLE DEPT_COPY3
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY3;

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT_COPY3';

ALTER TABLE DEPT_COPY3
RENAME COLUMN DEPT_ID TO DEPT_CODE;

ALTER TABLE DEPT_COPY3
ADD CONSTRAINT PK_DEPT_CODE2 PRIMARY KEY(DEPT_CODE);

ALTER TABLE DEPT_COPY3
RENAME CONSTRAINT PK_DEPT_CODE2 TO PK_DCODE;

-- 테이블 이름 변경
ALTER TABLE DEPT_COPY3
RENAME TO DEPT_TEST;

SELECT * FROM DEPT_COPY3;
SELECT * FROM DEPT_TEST;

-- 테이블 삭제
DROP TABLE DEPT_TEST CASCADE CONSTRAINT;










